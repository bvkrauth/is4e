# Using R {#using-r}

```{r setup11, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      prompt = FALSE,
                      tidy = FALSE,
                      collapse = TRUE)
library("tidyverse")
EmpData <- read_csv("sampledata/EmploymentData.csv")
```

In a previous chapter we learned some 
[basic R terminology and how to run R](#an-introduction-to-r), and how to use R
to [read and view data](#reading-and-viewing-data-in-r). We are now ready to
start using R with real data.

This chapter will use R to clean and analyze the historical Canadian employment
data. We will also use ggplot, a powerful graphing system that is part of the
Tidyverse package.

::: {.goals data-latex=""}
**Chapter goals**

In this chapter, we will learn how to:

1.  Use the pipe operator.
2.  Use the `mutate` function to add or modify variables in a data table.
3.  Use the `filter`, `select`, and `arrange` functions to modify a data table.
4.  Calculate a univariate statistic in R.
5.  Construct a table of summary statistics in R.
6.  Recognize and handle missing data problems in R.
7.  Construct a simple or binned frequency table in R.
8.  Perform simple probability calculations in R.
9.  Create a histogram with ggplot.
10. Create a line graph with ggplot.
:::

To prepare for this chapter, review the [introduction to R](#introduction-to-r).
Then open R, load the Tidyverse, and read in our employment data:

```{r ReadEmpDataFromCSV_11, eval=FALSE}
library(tidyverse)
EmpData <- read_csv("https://bookdown.org/bkrauth/IS4E/sampledata/EmploymentData.csv")
```

## Data cleaning in R {#data-cleaning-in-r}

We will not spend a lot of time on data cleaning in R, as we can always clean
data in Excel and export it to R. However, we have a few Tidyverse tools that
are useful to learn.

The Tidyverse includes four core functions for modifying data: 

- `mutate()` allows us to add or change variables.
- `filter()` allows us to select particular observations, much like Excel's
  filter tool.
- `arrange()` allows us to sort observations, much like Excel's sort tool.
- `select()` allows us to select particular variables.

All four functions follow a common syntax that is designed to work with a
convenient Tidyverse tool called the "pipe" operator.

### The pipe operator

The ***pipe operator*** is part of the Tidyverse and is written `%>%`. Recall 
that an operator is just a symbol like `+` or `*` that performs some function
on whatever comes before it and whatever comes after it.

The pipe operator is unusual because it doesn't allow you to *do* anything new.
Instead, it makes your code easier to read. To see how it works, I will show you
a few examples.

:::example
**The pipe operator**

```{r PipeExamples}
# This is equivalent to names(EmpData)
EmpData %>% names()
# This is equivalent to sqrt(2)
2 %>% sqrt()
# This is equivalent to cat(sqrt(2)," is the square root of 2")
2 %>% sqrt() %>% cat(" is the square root of 2")
```
:::

As you can see from the examples, R's rule for interpreting the pipe operator is
that the object *before* the `%>%` is taken as the first argument for the
function *after* the `%>%`.

The pipe operator does not add any functionality to R; anything you can do with
it can also be done without it.  But it addresses a common problem: we often 
want to perform multiple transformations on a data set, but doing so in the
usual functional language can lead to code that is quite difficult to read. The
pipe operator can be used to create much more readable code, as we will see in
the examples below.

### Mutate

The most important data transformation function is ***mutate***, which allows us
to change or add variables.

:::example
**Using `mutate()` to modify a variable**

We will start by changing  the **MonthYr** variable from character (text) to
date, using the `as.Date()` function:
```{r MutateChangeMonthYr}
# Change MonthYr to date format
EmpData %>% 
  mutate(MonthYr = as.Date(MonthYr, "%m/%d/%Y"))
```
As you can see, the **MonthYr** column is now labeled as a date rather than
text. Like Excel, R has an internal representation of dates that allows for
correct ordering and calculations, but displays dates in a standard
human-readable format.
:::

Mutate can be used to add variables as well as changing them.

:::example
**Using `mutate()` to add a variable**

Suppose we want to create versions of **UnempRate** and **LFPRate** that are
expressed in percentages rather than decimal units:
```{r MutateAddUnempPct}
# Add UnempPct and LFPPct
EmpData %>% 
  mutate(UnempPct = 100*UnempRate) %>% 
  mutate(LFPPct = 100*LFPRate)
```
If you look closely, you can see that the **UnempPct** and **LFPPct** variables
are now included in the data table.
:::

Before we go any further, note that `mutate()` is a function that *returns* a
*new* data table.  In order to actually change the original data table, we will
need to use the assignment (`<-`) operator.

:::example
**Modifying a data table**

Take a look at `EmpData` data table.
```{r PrintEmpDataAgain}
print(EmpData)
```
As you can see, the **MonthYr** variable is still listed as a character variable
and the new **UnempPct** and **LFPPct** variables do not seem to exist.

In order to change `EmpData` itself, we need to assign that new object *back*
to `EmpData`.
```{r MutatePermanently}
# Make permanent changes to EmpData
EmpData <- EmpData %>%
  mutate(MonthYr = as.Date(MonthYr, "%m/%d/%Y")) %>% 
  mutate(UnempPct = 100*UnempRate) %>% 
  mutate(LFPPct = 100*LFPRate)
```
We can confirm that now we have changed `EmpData`: **MonthYr** is a date
variable, and the variables **UnempPct** and **LFPPct** are part of the table.
```{r ConfirmPermanence}
print(EmpData)
```
:::

### Filter, select, and arrange

Excel provides a tool called "filtering" that allows you to choose observations
according to some criteria you specify.  R has a function called `filter()`
that fills this purpose.

:::example
**Using `filter()` to choose observations**

Suppose we want to know more about the months in our data set with the *highest*
unemployment rates. We can use `filter()` for this purpose:
```{r FilterEmpData}
# This will give all of the observations with unemployment rates over 12.5%
EmpData %>% 
  filter(UnempPct > 12.5)
```
As you can see, only 8 of the 541 months in our data have unemployment rates
over 12.5% - the worst months of the 1982-83 recession, and April and May of
2020.
:::

Similarly, R has a function called `select()` that allows you to choose specific
variables.

:::example
**Using `select()` to choose variables**

Suppose that we only want to see a few pieces of information about the months
with the highest unemployment rates:
```{r SelectEmpData}
# This will take out all variables except a few
EmpData %>% 
  filter(UnempPct > 12.5) %>%
  select(MonthYr, UnempRate, LFPPct, PrimeMinister)
```
:::

Finally, R has a function called `arrange()` that sorts observations according
to some criteria you specify.

:::example
**Using `arrange()` to sort observations**

Suppose that we want to show months in descending order by unemployment rate
(i.e., the highest unemployment rate first).  We can use `arrange()` to sort
rows in this way:
```{r ArrangeEmpData}
# This will sort the rows by unemployment rate
EmpData %>% 
  filter(UnempPct > 12.5) %>%
  select(MonthYr, UnempPct, LFPPct, PrimeMinister) %>%
  arrange(UnempPct)
```
:::

Now I should probably say: these results imply nothing meaningful about the
economic policy of either Pierre or Justin Trudeau.  The severe worldwide
recessions in 1982-83 (caused by US monetary policy) and 2020-2021 (caused 
by the COVID-19 pandemic) were caused by world events largely outside the 
control of Canadian policy makers.

:::example
**The usefulness of the pipe operator**

I mentioned earlier that the pipe operator is never strictly necessary, and that
it is always possible to write equivalent R code without it. But it does make
our code substantially more clear and readable.

```{r WithoutPipe, eval=FALSE}
# Here is some code using the pipe
EmpData %>%
  filter(UnempPct > 12.5) %>%
  select(MonthYr, UnempPct, LFPPct, PrimeMinister) %>%
  arrange(UnempPct)
# This is what the same code looks like without the pipe
arrange(select(filter(EmpData,UnempPct>12.5),MonthYr,UnempPct,LFPPct,PrimeMinister),UnempPct)
```
:::

### Saving code and data

It is possible to save your data set in R's internal format just like you would
save an Excel file.  But I'm not going to tell you how to do that, because what
you *really* need to do is save your code.

Because it is command-based, R enables an entirely different and much more
reproducible model for data cleaning and analysis.  In Excel, the original data,
the data cleaning, the data analysis, and the results are all mixed in together
in a single file or even a single worksheet. This is convenient and simple to
use in many applications, but it can lead to disaster in more complex projects.

In contrast, R allows you to have three separate files or groups of files

1. Your **source data**
   - Leave it exactly as you originally obtained it.
2. Your **code** to clean and analyze the data
   - Maintain it carefully using master versions, working copies and archives.
   - Your code can be saved in an R script, or as part of an R Markdown document.
   - Your code can be split into multiple files, for example one file to clean
     the data and another to analyze it.
3. Your **cleaned data** and **results**
   - Treat them as temporary output files.
   - You can regenerate your cleaned data and results at any time by running
     your code.

The key is to make sure that all of your cleaned data and results can be 
regenerated from the original data at any time by running your code.

:::example
**Creating an R script to clean our data**

Create an R script called `EmpData.R` with the following code:
```{r fullScript, eval=FALSE}
# Load the Tidyverse
library(tidyverse)
# Load the data
EmpData <- read_csv("https://bookdown.org/bkrauth/IS4E/sampledata/EmploymentData.csv")
# Clean the data
EmpData <- EmpData %>%
  mutate(MonthYr = as.Date(MonthYr, "%m/%d/%Y")) %>%
  mutate(UnempPct = 100*UnempRate) %>%
  mutate(LFPPct = 100*LFPRate)
```
:::

## Data analysis in R {#data-analysis-in-r}

Having read and cleaned our data set, we can now move on to some summary 
statistics.

### The summary function

The `summary()` function will give a basic summary of any object.  Exactly what
that summary looks like depends on the object. For tibbles, `summary()` produces
a set of summary statistics for each variable:

::: example
**Summarizing a data table**

```{r SummaryEmpData}
summary(EmpData)
```
:::

### Univariate statistics 

The R function `mean()` calculates the sample average of any numeric vector.
There are also functions to calculate variance, standard deviation, and other
summary statistics.

::: example
**Univariate statistics for a single variable**

```{r MeanUnempPct}
# MEAN calculates the mean of a single variable
mean(EmpData$UnempPct)
# VAR calculates the sample variance
var(EmpData$UnempPct)
# SD calculates the standard deviation
sd(EmpData$UnempPct)
# MEDIAN calculates the sample median
median(EmpData$UnempPct)
```
:::

In real-world data, some variables have ***missing values*** for one or more
observations. Values can be missing for various reasons: information may be
unavailable, or the variable may not be applicable to the case.  In R, missing
values are given the special value `NA` which stands for "not available."

::: example
**Missing values in the employment data**

The *AnnPopGrowth* variable in our data set is missing for the first year of
data (1976), since calculating the growth rate for 1976 would require data from
1975, and we don't have that data.

```{r ShowMissingValues}
EmpData %>%
  select(MonthYr, Population, AnnPopGrowth)
```
:::


By default, math in R follows the [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754)
standard for numerical arithmetic, which says that any calculation
involving `NA` should also result in `NA`.

::: example
**Calculations with `NA` produce `NA`**

```{r MeanAnnPopGrowth}
# Some values of AnnPopGrowth are NA, so its mean is also NA
mean(EmpData$AnnPopGrowth)
# The same goes for other statistics:
sd(EmpData$AnnPopGrowth)
var(EmpData$AnnPopGrowth)
median(EmpData$AnnPopGrowth)
```
:::

Some applications automatically drop missing data from the calculation. This is
a simple solution, but R does what it does for a good reason. Missing values
can be a sign of an error in the data or code, so we should always catch them
and investigate their cause before dropping them.

Once we have investigated the missing values, we can tell R explicitly to
exclude them from the calculation by adding the `na.rm = TRUE` optional
argument.

::: example
**Handling missing values**

In the case of our **AnnPopGrowth** variable, We know why it is missing: we
cannot calculate annual growth rates in the first year of our data. So we can
exclude the missing values.

```{r MeanAnnPopGrowthWithoutNA}
# We can add the na.rm = TRUE argument to drop the missing values
mean(EmpData$AnnPopGrowth, na.rm = TRUE)
# These lines of code will do the same thing:
mean(na.omit(EmpData$AnnPopGrowth))
mean(EmpData$AnnPopGrowth[!is.na(EmpData$AnnPopGrowth)])
```
:::

### Tables of statistics 

Suppose we want to calculate the sample average for each column in our tibble.
We could just call `mean()` for each of them, but there is a quicker way.

:::example
**Producing a table of statistics**

Here is the code to do that:
```{r MeanTable}
# Mean of each column
EmpData %>%
  select(where(is.numeric)) %>%
  lapply(mean, na.rm = TRUE) 
```
I would not expect you to come up with this code, but maybe it kind of makes
sense.  

- The `select(where(is.numeric))` step selects only the columns in 
  `EmpData` that are numeric rather than text. 
- The `lapply(mean,na.rm=TRUE)` step calculates `mean(x,na.rm=TRUE)` 
  for each (numeric) column `x` in `EmpData`. 
  
We can use this method with any function that calculates a summary statistic:
```{r SDTable}
# Standard deviation of each column
EmpData %>%
  select(where(is.numeric)) %>%
  lapply(sd, na.rm = TRUE) 
```
:::

### Frequency tables 

We can construct simple frequency tables for discrete variables using the 
`count()` function

::: example
**Using `count()` to make a simple frequency table**

```{r CountTables}
# COUNT creates a frequency table for discrete variables
EmpData %>% 
  count(PrimeMinister)
```
:::

We can also construct binned frequency tables for continuous variables using
the `count()` function in combination with the `cut_interval()` function.

::: example
**Using `count()` to make a binned frequency table**

```{r BinCountTables}
# COUNT and CUT_INTERVAL create a binned frequency table
EmpData %>% 
  count(cut_interval(UnempPct, 6))
```
:::

As you might imagine, there are various ways of customizing the intervals just
like in Excel.

### Probability distributions in R

Just like Excel, R has a family of built-in functions for each commonly-used
probability distribution.

::: example
**Some probability distributions**

The  `dnorm()`, `pnorm()`, and `qnorm()` functions return PDF, CDF, and quantile
functions of the normal distribution, while the `rnorm()` function returns a
vector of normally distributed random numbers:
  ```{r}
  # The N(0,1) PDF, evaluated at 1.96
  dnorm(1.96)
  # The N(1,4) PDF, evaluated at 1.96
  dnorm(1.96,mean=1,sd=4)
  # The N(0,1) CDF, evaluated at 1.96
  pnorm(1.97)
  # The 97.5 percentile of the N(0,1) CDF
  qnorm(0.975)
  # Four random numbers from the N(0,1) distribution
  rnorm(4)
  ```
There is a similar set of functions available for the uniform distribution
(`dunif`, `punif`, `qunif`, `runif`), the binomial distribution (`dbinom`,
`pbinom`, `qbinom`,`rbinom`), and Student's T distribution (`dt`, `pt`, `qt`,
`rt`), along with many others.
:::

## Graphs with ggplot {#graphs-with-ggplot}

The Tidyverse also contains a powerful graphics package called[^1101]
***ggplot***. The ggplot package has capabilities well beyond what R's built-in
commands can do, or what Excel can do.

[^1101]: The package is technically called `ggplot2` since it is the second
       version of `ggplot`.  But everyone calls it "ggplot" anyway.

### Creating a graph

The `ggplot` function can be used to create a graph.  It has a non-standard
syntax.

::: example
**Two ggplot graphs**

We can start by making a histogram of the unemployment rate, much like the one
we made earlier in Excel
```{r ggplotHistogram}
ggplot(data = EmpData,
       mapping = aes(x = UnempPct)) + 
  geom_histogram()
```

We can also make a time series (line) graph, much like the one we made earlier
in Excel.
```{r ggplotTimeSeries}
ggplot(data = EmpData,
       mapping = aes(x = MonthYr, 
                     y = UnempPct)) + 
  geom_line() 
```
:::


The `ggplot()` function has a non-standard syntax, so some explanation is
needed:

- The first expression/line calls `ggplot()` to set up the basic structure of
  the graph:
    - The `data` argument tells R which data set (tibble) will be used.
    - the `mapping` argument describes the main ***aesthetics*** of the graph,
      i.e., the relationship in the data we will be graphing.
      - For the histogram, our aesthetic includes only one variable.
      - For the line graph, our aesthetic includes two variables.
- The rest of the command is one or more statements separated by a `+` sign.
  These are called ***geometries*** and are graph elements to be included in the
  plot.
    - The `geom_histogram()` geometry produces a histogram.
    - The `geom_line()` geometry produces a line.

A single graph can include multiple geometries, as we will see shortly.

### Modifying a graph

As when making graphs in Excel, the basic ggplot graph gives us some useful
information but we can improve upon it in various ways.

#### Titles and labels

You can use `labs()` to add titles, subtitles, alt text, etc.  You can also use
`xlab()` and `ylab()` to change the axis titles.

:::example
**Modifying titles and labels**


```{r ggplotTitles}
ggplot(data = EmpData,
       aes(x = MonthYr, 
           y =UnempPct)) + 
  geom_line() + 
  labs(title = "Unemployment rate",
      subtitle = "January 1976 - January 2021",
      alt = "Time series of Canada unemployment rate, January 1976 - January 2021",
      caption = "Source: Statistics Canada, Labour Force Survey",
      tag = "Canada") +
  xlab("") +
  ylab("Unemployment rate, %")
```
:::

#### Color 

You can change the color of any geometric element using the `col=` argument.

::: example
**Using colors**

```{r ggplotColor}
ggplot(data = EmpData,
       aes(x = MonthYr, 
           y = UnempPct)) + 
  geom_line(col = "darkorange")
```
:::

Colors can be given in ordinary English (or local language) words like "red"
or "blue." You can get the full list of built-in color names by executing the
expression `colors()` in the command window.  You can also set custom colors
using color codes in RGB or CMYK format.

Some geometric elements, such as the bars in a histogram, also have a
***fill*** color.

:::example
**Setting the fill color***

```{r ggplotFill}
ggplot(data = EmpData,
       aes(x = UnempPct)) + 
  geom_histogram(col = "darkorange",
                 fill = "navyblue")
```

As you can see, the `col=` argument sets the color for the exterior of each bar,
and the `fill=` argument sets the color for the interior.
:::

### Adding graph elements 

We can include multiple geometries in the same graph.

::: example
**Including multiple lines**

We can include lines for both unemployment and labour force participation:
```{r ggplotTwoLines}
ggplot(data = EmpData,
       aes(x = MonthYr, 
           y = UnempPct)) + 
  geom_line(col = "navyblue") +
  geom_line(aes(y = LFPPct),
            col = "darkorange")
```

A few things to note here:

- The third line gives `geom_line()` an aesthetics argument `aes(y=LFPPct)`.  This
  overrides the aesthetics in the first line.  
- We have used color to differentiate the two lines, but there is no legend or
  label to tell the reader which line is which.  We will need to fix that.
- The vertical axis is labeled **UnempPct** which is the name of one of the
  variables but not the other. We will need to fix that.
:::

When including multiple elements, we may need to add information clarify what
element describes.  We can add a legend, but it is better (and friendlier to
the color-blind) to just label the lines. We can use the `geom_text` geometry
to do this:

:::example
**Using `geom_text()` to add text**

```{r ggplotAddText}
ggplot(data = EmpData,
       aes(x = MonthYr)) + 
  geom_line(aes(y = UnempPct),
            col = "navyblue") +
  geom_text(x = as.Date("1/1/2000", "%m/%d/%Y"),
            y = 15,
            label = "Unemployment",
            col = "navyblue") +
  geom_line(aes(y = LFPPct),
            col = "darkorange") +
  geom_text(x = as.Date("1/1/2000", "%m/%d/%Y"),
            y = 60,
            label = "LFP",
            col = "darkorange")
```
:::

Finally, we can combine all of these elements.

::: example
**Fancy graphs**

The graphs below combine all of the features described above:
```{r ggplotFancyHistogram}
# Use RGB codes to exactly match color scheme of this book
AstroBlue <- "#002D62"
AstroOrange <- "#EB6E1F"
# Fancy histogram
ggplot(data = EmpData,
       aes(x = UnempPct)) + 
  geom_histogram(binwidth = 0.5,
                 fill = AstroBlue) +
  geom_density() +
  labs(title = "Unemployment rate",
      subtitle = paste("January 1976 - January 2021 (",
                     nrow(EmpData),
                     " months)",
                     sep = "",
                     collapse = ""),
      alt = "Histogram of Canada unemployment rate, January 1976 - January 2021",
      caption = "Source: Statistics Canada, Labour Force Survey",
      tag = "Canada") +
  xlab("Unemployment rate, %") +
  ylab("Count")
```

```{r ggplotFancyTimeSeries}
# Use RGB codes to exactly match color scheme of this book
AstroBlue <- "#002D62"
AstroOrange <- "#EB6E1F"
# Fancy time series plot
ggplot(data = EmpData,
       aes(x = MonthYr)) + 
  geom_line(aes(y = UnempPct),
            col = AstroBlue) +
  geom_text(x = as.Date("1/1/2000", "%m/%d/%Y"),
            y = 15,
            label = "Unemployment", col=AstroBlue) +
  geom_line(aes(y = LFPPct),
            col = AstroOrange) +
  geom_text(x = as.Date("1/1/2000", "%m/%d/%Y"),
            y = 60,
            label = "LFP",
            col = AstroOrange) +
  labs(title = "Unemployment and LFP rates",
      subtitle = paste("January 1976 - January 2021 (",
                     nrow(EmpData),
                     " months)",
                     sep = "",
                     collapse = ""),
      alt = "Time series of Canada unemployment and LFP, January 1976 - January 2021",
      caption = "Source: Statistics Canada, Labour Force Survey",
      tag = "Canada") +
  xlab("") +
  ylab("Percent")
```
:::


## Chapter review {-#review-using-r}

As we have seen, we can do many of the same things in Excel and R.  R is
typically more difficult to use for simple analysis tasks, and there is nothing 
wrong with using Excel when it is easier.  But the usability gap gets smaller
with more complicated tasks, and there are many tasks where Excel doesn't do
everything that R can do. You should think of them as complementary tools, and
be comfortable using both.

In this chapter we learned how to use the pipe operator, the four key Tidyverse
functions for cleaning data, and the necessary tools for calculating univariate
statistics.  In addition, we learned the basics of ggplot.

Our next applications of R will be for the analysis of relationships between
[multiple variables](#multivariate-data-analysis).  The capabilities of ggplot
for constructing graphical elements like scatter plots and curve fits will be
well beyond what you can do in Excel, and will hopefully justify your investment
in learning R.

## Practice problems {-#problems-using-r}

Answers can be found in the [appendix](#answers-using-r).

**GOAL #1: Use the pipe operator**
**GOAL #2: Use the mutate function to add or change a variable**
**GOAL #3: Use the filter, select, and arrange functions to modify a data table**

1. Starting with the data table `EmpData`:
   a. Add the numeric variable **Year** based on the existing variable **MonthYr**. The
      formula for **Year** should be `format(MonthYr, "%Y")`.
   b. Add the numeric variable **EmpRate**, which is the proportion of the population
      (**Population**) that is employed (**Employed**), also called the employment
      rate or employment-to-population ratio.
   b. Drop all observations from years before 2010.
   c. Drop all variables except **MonthYr**, **Year**, **EmpRate**, **UnempRate**, 
      and **AnnPopGrowth**.
   d. Sort observations by **EmpRate**.
   e. Give the resulting data table the name `PPData`.

**GOAL #4: Calculate a univariate statistic in R**
**GOAL #5: Construct a table of summary statistics in R**
**GOAL #6: Recognize and handle missing data problems in R**

2. Starting with the `PPData` data table you created in question (1) above:
   a. Calculate and report the mean employment rate since 2010.
   b. Calculate and report a table reporting the median for all variables in
      `PPData`.
   c. Did any variables in `PPData` have missing data?  If so, how did you
      decide to address it in your answer to (b), and why?

**GOAL #7: Construct a simple or binned frequency table in R**

3. Using the `PPData`data set, construct a frequency table of the employment
   rate.

**GOAL #8: Perform simple probability calculations in R**

4. Calculate the following quantities in R:
   a. The 45th percentile of the $N(4,6)$ distribution.
   b. The 97.5 percentile of the $T_8$ distribution.
   c. The value of the standard uniform CDF, evaluated at 0.75.
   d. 5 random numbers from the $Binomial(10,0.5)$ distribution.

**GOAL #9: Create a histogram with ggplot**

5. Using the `PPData`data set, create a histogram of the employment rate.

**GOAL #10: Create a line graph with ggplot**

6. Using the `PPData` data set, create a time series graph of the employment
   rate.
